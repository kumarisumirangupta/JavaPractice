Static and default method inheritance

In Java, inheritance/behavior of methods differs for static, default, and normal instance methods, especially when interfaces and classes are involved.Letâ€™s break it clearly + interview-ready, with rules and examples.

1ï¸âƒ£ Static Methods in Interface

ğŸ”¹ Key Rules

Static methods in interfaces are NOT inherited

They belong to the interface, not to implementing classes

Must be called using InterfaceName.method()

Cannot be overridden

âœ… Example

interface A {
    static void show() {
        System.out.println("Static method in interface A");
    }
}

class B implements A {
}

public class Test {
    public static void main(String[] args) {
        A.show();     // âœ… valid
        // B.show();  âŒ compile-time error
    }
}


ğŸ” Explanation

show() is tied to A

B does not inherit it

Even though B implements A, static methods donâ€™t participate in inheritance

ğŸ“Œ Interview line:

Static methods in interfaces are not inherited; they must be accessed using the interface name.

2ï¸âƒ£ Static Methods in Class

ğŸ”¹ Key Rules

Static methods are inherited, but NOT overridden

They can be hidden (method hiding)

Method call depends on reference type, not object

âœ… Example

class Parent {
    static void display() {
        System.out.println("Parent static method");
    }
}

class Child extends Parent {
    static void display() {
        System.out.println("Child static method");
    }
}

public class Test {
    public static void main(String[] args) {
        Parent p = new Child();
        p.display();   // Parent static method
        Child.display(); // Child static method
    }
}


ğŸ” Explanation

This is method hiding, not overriding

Compile-time binding

JVM decides based on reference type

ğŸ“Œ Interview line:

Static methods are inherited but cannot be overridden; they support method hiding.

3ï¸âƒ£ Default Methods in Interface

ğŸ”¹ Key Rules

Default methods ARE inherited

Can be overridden by implementing class

Provide backward compatibility (Java 8)

âœ… Example

interface A {
    default void greet() {
        System.out.println("Hello from interface A");
    }
}

class B implements A {
}

public class Test {
    public static void main(String[] args) {
        B b = new B();
        b.greet(); // Hello from interface A
    }
}


ğŸ” Explanation

Default method behaves like an instance method

Automatically available to implementing class

4ï¸âƒ£ Overriding Default Method in Class

âœ… Example

class B implements A {
    @Override
    public void greet() {
        System.out.println("Hello from class B");
    }
}


ğŸ“Œ Rule:Class implementation always wins over interface default method.

5ï¸âƒ£ Multiple Interfaces with Same Default Method (Diamond Problem)

âŒ Problem

interface A {
    default void greet() {
        System.out.println("A");
    }
}

interface C {
    default void greet() {
        System.out.println("C");
    }
}

class B implements A, C {
}


âŒ Compile-time error

âœ… Solution (Must override)

class B implements A, C {
    @Override
    public void greet() {
        A.super.greet(); // or C.super.greet()
    }
}


ğŸ“Œ Interview line:

If multiple interfaces provide the same default method, the implementing class must override it.

6ï¸âƒ£ Interface Default vs Class Method

Rule

ğŸ‘‰ Class method has higher priority than interface default method

Example

class Parent {
    public void greet() {
        System.out.println("Parent class");
    }
}

interface A {
    default void greet() {
        System.out.println("Interface A");
    }
}

class Child extends Parent implements A {
}


Output

Parent class


ğŸ“Œ Interview line:

Class methods override interface default methods automatically.

ğŸ¯ One-Line Interview Summary

Static methods do not support runtime polymorphism, default methods do, and class methods always take precedence over interface default methods.